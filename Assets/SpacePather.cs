using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class SpacePather : PoolBehaviour {
	public Blockform pathForm;
	public Rect colRect;
	public float pathGridSize;

	public List<Vector2> lastPath;
	public Vector2[] cardinals;

	public bool IsPassable(Vector2 pos) {
        var bounds = new Bounds(pos, pathForm.localBounds.size);

        foreach (var col in Physics.OverlapSphere(pos, pathForm.length, SpaceLayer.ShipBounds)) {
            if (col.attachedRigidbody != pathForm.rigidBody)
                return false;
        }

		return true;
	}

	public IEnumerable<Vector2> Cardinals() {
		yield return (Vector2)transform.TransformVector(Vector2.down);
		yield return (Vector2)transform.TransformVector(Vector2.left);
		yield return (Vector2)transform.TransformVector(Vector2.right);
		yield return (Vector2)transform.TransformVector(Vector2.up);
	}

	public IEnumerable<Vector2> Neighbors(Vector2 pos) {
		return cardinals.Select((c) => pos + c*pathGridSize);
	}

	public List<Vector2> PathBetween(Vector2 start, Vector2 end, List<Vector2> currentPath = null) {
		if (!IsPassable(end)) return null;
		cardinals = Cardinals().ToArray();

		var dir = (end-start).normalized;

		var seen = new HashSet<Vector2>();
		var cameFrom = new Dictionary<Vector2, Vector2>();
		var currentDistance = new Dictionary<Vector2, float>();

		var heads = new Stack<Vector2>();
		heads.Push(start);
		currentDistance.Add(start, 0f);

		while (heads.Count > 0) {
			var head = heads.Pop();
			seen.Add(head);

			// process each valid node around the current node
			foreach (var neighbor in Neighbors(head).OrderBy((n) => -Vector2.Distance(n, end) - Vector2.Distance(n, start)/seen.Count)) {
				if (!IsPassable(neighbor)) {//if (Util.ShipCast(pathForm, head, neighbor).Any()) {
					continue;
				}
				
				var tempCurrentDistance = currentDistance[head] + pathGridSize;

				if (seen.Contains(neighbor) && tempCurrentDistance >= currentDistance[head])
					continue;

				if (Vector2.Distance(neighbor, end) <= pathGridSize) {
					cameFrom[neighbor] = head;
					cameFrom[end] = neighbor;
					lastPath = ReconstructPath(cameFrom, end);
					return lastPath;
				}

				Debug.DrawLine(head, neighbor, Color.Lerp(Color.white, Color.cyan, heads.Count/100f));

				currentDistance[neighbor] = tempCurrentDistance;
				if (head != start)
					cameFrom[neighbor] = head;
				heads.Push(neighbor);
			}

			if (heads.Count > 1000) {
				Debug.LogWarning("Pathfinding node count exceeded, aborting");
				return null;
			}			
		}
		
		// unable to figure out a path, abort.
		return null;

	}

	public List<Vector2> PathFromNose(Vector2 dest) {
		return PathBetween(pathForm.transform.position + pathForm.transform.TransformDirection(Vector2.up)*pathForm.blocks.maxY, dest);
	}

	/// <summary>
	/// Process a list of valid paths generated by the Pathfind function and return 
	/// a coherent path to current.
	/// </summary>
	/// <param name="cameFrom">A list of nodes and the origin to that node.</param>
	/// <param name="current">The destination node being sought out.</param>
	/// <returns>The shortest path from the start to the destination node.</returns>
	public List<Vector2> ReconstructPath(Dictionary<Vector2, Vector2> cameFrom, Vector2 current) {
		var invPath = new List<Vector2>();
		while (true) {
			invPath.Add(current);
			if (!cameFrom.ContainsKey(current))
				break;
			current = cameFrom[current];
		}

		invPath.Reverse();
		var path = new List<Vector2>();

		for (var i = 0; i < invPath.Count-1; i++) {
			if (!Util.ShipCast(pathForm, invPath[i]).Any())
				continue;

			path.Add(invPath[i]);
		}

		path.Add(invPath.Last());

		return path;
	}

	void Update() {
	}

	void Awake() {
		pathForm = GetComponent<Blockform>();
    }

    void Start() {    
		var width = (pathForm.blocks.maxX - pathForm.blocks.minX) * Tile.worldSize;
		var height = (pathForm.blocks.maxY - pathForm.blocks.minY) * Tile.worldSize;
		colRect = new Rect(-width/2, -height/2, width, height);
		pathGridSize = Math.Max(colRect.width, colRect.height)*1.5f;
	}
}

using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class SpacePather : PoolBehaviour {
	public Blockform pathForm;
	public Rect colRect;
	public float pathGridSize;

	public List<Vector2> lastPath;

	public bool IsPassable(Vector2 pos) {
		var corners = Util.RectCorners(colRect).ToList();
		foreach (var form in Game.activeSector.blockforms) {
			if (form == pathForm) continue;
			foreach (var corner in corners) {
				if (form.pather.colRect.Contains(form.transform.InverseTransformPoint(pos+corner)))
					return false;
			}
		}

		return true;
	}

	public Vector2[] Neighbors(Vector2 dir, Vector2 pos) {
		var dist = pathGridSize;
		transform.rotation = Quaternion.LookRotation(Vector3.forward, dir);
		var left = (Vector2)transform.TransformVector(Vector2.left*dist);
		var right = (Vector2)transform.TransformVector(Vector2.right*dist);
		var down = (Vector2)transform.TransformVector(Vector2.down*dist);
		var up = (Vector2)transform.TransformVector(Vector2.up*dist);
		return new Vector2[] {
			pos + left,
			pos + right,
			pos + down,
			pos + up
		};
	}

	public List<Vector2> PathBetween(Vector2 start, Vector2 end) {
		if (!IsPassable(end)) return null;

		Debug.DrawLine(start, end);

		var dir = (end-start).normalized;

		var closedSet = new HashSet<Vector2>();
		var openSet = new HashSet<Vector2> { start };
		var cameFrom = new Dictionary<Vector2, Vector2>();
		var currentDistance = new Dictionary<Vector2, float>();
		var predictedDistance = new Dictionary<Vector2, float>();
		
		// initialize the start node as having a distance of 0, and an estmated distance 
		// of a straight line
		currentDistance.Add(start, 0);
		predictedDistance.Add(start, Vector2.Distance(start, end));

		// if there are any unanalyzed nodes, process them
		while (openSet.Count > 0) {
			if (openSet.Count > 100) {
				Debug.LogWarning("Pathfinding node count exceeded, aborting");
				return null;
			}
			var current = openSet.OrderBy((n) => predictedDistance[n]).First();
			
			// if it is the finish, return the path
			if (Vector2.Distance(current, end) <= pathGridSize) {
				// generate the found path
				cameFrom[end] = current;
				lastPath = ReconstructPath(cameFrom, end);
				return lastPath;
			}
			
			// move current node from open to closed
			openSet.Remove(current);
			closedSet.Add(current);
			
			// process each valid node around the current node
			foreach (var neighbor in Neighbors(dir, current)) {
				if (Vector2.Distance(start, neighbor) > Game.activeSector.sector.radius*2 || (neighbor != start && !IsPassable(neighbor))) {
					continue;
				}

				Debug.DrawLine(current, neighbor);

				var tempCurrentDistance = currentDistance[current] + pathGridSize;
				
				// if we already know a faster way to this neighbor, use that route and 
				// ignore this one
				if (closedSet.Contains(neighbor) && tempCurrentDistance >= currentDistance[neighbor]) {
					continue;
				}
				
				cameFrom[neighbor] = current;
				
				currentDistance[neighbor] = tempCurrentDistance;
				predictedDistance[neighbor] =
					currentDistance[neighbor] + Vector2.Distance(neighbor, end);

				openSet.Add(neighbor);
			}
		}
		
		// unable to figure out a path, abort.
		return null;

	}

	/// <summary>
	/// Process a list of valid paths generated by the Pathfind function and return 
	/// a coherent path to current.
	/// </summary>
	/// <param name="cameFrom">A list of nodes and the origin to that node.</param>
	/// <param name="current">The destination node being sought out.</param>
	/// <returns>The shortest path from the start to the destination node.</returns>
	public static List<Vector2> ReconstructPath(Dictionary<Vector2, Vector2> cameFrom, Vector2 current) {
		if (!cameFrom.Keys.Contains(current)) {
			return new List<Vector2> { current };
		}
		
		var path = ReconstructPath(cameFrom, cameFrom[current]);
		path.Add(current);
		return path;
	}


	void Update() {
		DebugUtil.DrawRect(pathForm.transform, colRect);
		if (lastPath != null) DebugUtil.DrawPath(lastPath);
	}

	void Awake() {
		pathForm = GetComponentInParent<Blockform>();
		var width = (pathForm.blocks.maxX - pathForm.blocks.minX) * Tile.worldSize;
		var height = (pathForm.blocks.maxY - pathForm.blocks.minY) * Tile.worldSize;
		colRect = new Rect(-width/2, -height/2, width, height);
		pathGridSize = Math.Max(colRect.width, colRect.height);
	}
}

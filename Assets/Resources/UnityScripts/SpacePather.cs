using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class SpacePather : PoolBehaviour {
	public Blockform pathForm;
	public Rect colRect;
	public float pathGridSize;

	public List<Vector2> lastPath;

	public bool IsPassable(Vector2 pos) {
		var corners = Util.RectCorners(colRect).ToList();
		foreach (var form in Game.activeSector.blockforms) {
			if (form == pathForm) continue;
			foreach (var corner in corners) {
				if (form.pather.colRect.Contains(form.transform.InverseTransformPoint(pos+corner)))
					return false;
			}
		}

		return true;
	}

	public Vector2[] Cardinals() {
		var up = (Vector2)transform.TransformVector(Vector2.down);
		var left = (Vector2)transform.TransformVector(Vector2.left);
		var right = (Vector2)transform.TransformVector(Vector2.right);
		var down = (Vector2)transform.TransformVector(Vector2.up);
		return new Vector2[] { up, left, right, down };
	}

	public Vector2[] Neighbors(Vector2 pos) {
		return Cardinals().Select((c) => pos + c*pathGridSize).ToArray();
	}

	public List<Vector2> PathBetween(Vector2 start, Vector2 end) {
		if (!IsPassable(end)) return null;

		var dir = (end-start).normalized;

		var heads = new Stack<Vector2>();
		heads.Push(start);

		var seen = new HashSet<Vector2>();
		var cameFrom = new Dictionary<Vector2, Vector2>();
		var currentDistance = new Dictionary<Vector2, float>();

		currentDistance.Add(start, 0f);

		while (heads.Count > 0) {
			var head = heads.Pop();
			seen.Add(head);

			// process each valid node around the current node
			foreach (var neighbor in Neighbors(head).OrderBy((n) => -Vector2.Distance(n, end))) {
				if (neighbor != start && !IsPassable(neighbor)) {
					continue;
				}
				
				var tempCurrentDistance = currentDistance[head] + pathGridSize;

				if (seen.Contains(neighbor) && tempCurrentDistance >= currentDistance[head])
					continue;

				if (Vector2.Distance(neighbor, end) <= pathGridSize) {
					cameFrom[neighbor] = head;
					cameFrom[end] = neighbor;
					lastPath = ReconstructPath(cameFrom, end);
					return lastPath;
				}


				Debug.DrawLine(head, neighbor, Color.Lerp(Color.white, Color.cyan, heads.Count/100f));

				currentDistance[neighbor] = tempCurrentDistance;
				if (head != start)
					cameFrom[neighbor] = head;
				heads.Push(neighbor);
			}

			if (heads.Count > 1000) {
				Debug.LogWarning("Pathfinding node count exceeded, aborting");
				return null;
			}			
		}
		
		// unable to figure out a path, abort.
		return null;

	}

	/// <summary>
	/// Process a list of valid paths generated by the Pathfind function and return 
	/// a coherent path to current.
	/// </summary>
	/// <param name="cameFrom">A list of nodes and the origin to that node.</param>
	/// <param name="current">The destination node being sought out.</param>
	/// <returns>The shortest path from the start to the destination node.</returns>
	public List<Vector2> ReconstructPath(Dictionary<Vector2, Vector2> cameFrom, Vector2 current) {
		var invPath = new List<Vector2>();
		while (true) {
			invPath.Add(current);
			if (!cameFrom.Keys.Contains(current))
				break;
			current = cameFrom[current];
		}

		invPath.Reverse();
		return SmoothPath(invPath);
	}

	public List<Vector2> SmoothPath(List<Vector2> path) {
		var smoothed = new List<Vector2>();
		smoothed.Add(path[0]);
		for (var i = 1; i < path.Count-1; i++) {
			if (Util.ShipCast(pathForm, smoothed.Last(), path[i+1]).Count() > 0) {
				smoothed.Add(path[i]);
			}
		}
		smoothed.Add(path.Last());
		return smoothed;
	}


	void Update() {
		DebugUtil.DrawRect(pathForm.transform, colRect);
	}

	void Awake() {
		pathForm = GetComponentInParent<Blockform>();
		var width = (pathForm.blocks.maxX - pathForm.blocks.minX) * Tile.worldSize;
		var height = (pathForm.blocks.maxY - pathForm.blocks.minY) * Tile.worldSize;
		colRect = new Rect(-width/2, -height/2, width, height);
		pathGridSize = Math.Max(colRect.width, colRect.height)*1.5f;
	}
}

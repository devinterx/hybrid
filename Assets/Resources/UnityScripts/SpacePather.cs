using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class SpacePather : PoolBehaviour {
	public Blockform pathForm;
	public Rect colRect;
	public float pathGridSize;

	public List<Vector2> lastPath;

	public bool IsPassable(Vector2 pos) {
		var corners = Util.RectCorners(colRect).ToList();
		foreach (var form in Game.activeSector.blockforms) {
			if (form == pathForm) continue;
			foreach (var corner in corners) {
				if (form.pather.colRect.Contains(form.transform.InverseTransformPoint(pos+corner)))
					return false;
			}
		}

		return true;
	}

	public Vector2[] Neighbors(Vector2 pos) {
		var dist = pathGridSize;
		var left = (Vector2)transform.TransformVector(Vector2.left*dist);
		var right = (Vector2)transform.TransformVector(Vector2.right*dist);
		var down = (Vector2)transform.TransformVector(Vector2.down*dist);
		var up = (Vector2)transform.TransformVector(Vector2.up*dist);
		return new Vector2[] {
			pos + up,
			pos + left,
			pos + right,
			pos + down
		};
	}

	public List<Vector2> PathBetween(Vector2 start, Vector2 end) {
		if (!IsPassable(end)) return null;

		var dir = (end-start).normalized;
		transform.rotation = Quaternion.LookRotation(Vector3.forward, dir);

		var seen = new HashSet<Vector2>();
		var heads = new HashSet<Vector2> { start };
		var cameFrom = new Dictionary<Vector2, Vector2>();
				
		while (heads.Count > 0) {
			var head = heads.First();
			heads.Remove(head);
			seen.Add(head);

			// process each valid node around the current node
			foreach (var neighbor in Neighbors(head).OrderBy((n) => Vector2.Distance(n, end))) {
				if (seen.Contains(neighbor))
					continue;

				if (neighbor != start && !IsPassable(neighbor)) {
					seen.Add(neighbor);
					continue;
				}

				if (Vector2.Distance(neighbor, end) <= pathGridSize) {
					cameFrom[neighbor] = head;
					cameFrom[end] = neighbor;
					lastPath = ReconstructPath(cameFrom, end);
					return lastPath;
				}


				Debug.DrawLine(head, neighbor, Color.Lerp(Color.white, Color.cyan, heads.Count/100f));

				cameFrom[neighbor] = head;
				heads.Add(neighbor);
			}

			if (heads.Count > 1000) {
				Debug.LogWarning("Pathfinding node count exceeded, aborting");
				return null;
			}			
		}
		
		// unable to figure out a path, abort.
		return null;

	}

	/// <summary>
	/// Process a list of valid paths generated by the Pathfind function and return 
	/// a coherent path to current.
	/// </summary>
	/// <param name="cameFrom">A list of nodes and the origin to that node.</param>
	/// <param name="current">The destination node being sought out.</param>
	/// <returns>The shortest path from the start to the destination node.</returns>
	public static List<Vector2> ReconstructPath(Dictionary<Vector2, Vector2> cameFrom, Vector2 current) {
		if (!cameFrom.Keys.Contains(current)) {
			return new List<Vector2> { current };
		}
		
		var path = ReconstructPath(cameFrom, cameFrom[current]);
		path.Add(current);
		return path;
	}


	void Update() {
		DebugUtil.DrawRect(pathForm.transform, colRect);
	}

	void Awake() {
		pathForm = GetComponentInParent<Blockform>();
		var width = (pathForm.blocks.maxX - pathForm.blocks.minX) * Tile.worldSize;
		var height = (pathForm.blocks.maxY - pathForm.blocks.minY) * Tile.worldSize;
		colRect = new Rect(-width/2, -height/2, width, height);
		pathGridSize = Math.Max(colRect.width, colRect.height);
	}
}

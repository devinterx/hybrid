using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class SpacePather {
	public Blockform pathForm;
	public Rect colRect;

	public List<Vector2> lastPath;

	public bool IsPassable(Vector2 pos) {
		var corners = Util.RectCorners(colRect).ToList();
		foreach (var form in Game.activeSector.blockforms) {
			foreach (var corner in corners) {
				if (form.pather.colRect.Contains(form.transform.InverseTransformPoint(pos+corner)))
					return false;
			}
		}

		return true;
	}

	public Vector2[] Neighbors(Vector2 pos) {
		var width = colRect.width;
		var height = colRect.height;
		return new Vector2[] {
			new Vector2(pos.x-width, pos.y),
			new Vector2(pos.x+width, pos.y),
			new Vector2(pos.x, pos.y-height),
			new Vector2(pos.x, pos.y+height)
		};
	}

	public List<Vector2> PathBetween(Vector2 start, Vector2 end) {
		if (!IsPassable(end)) return null;

		var closedSet = new HashSet<Vector2>();
		var openSet = new HashSet<Vector2> { start };
		var cameFrom = new Dictionary<Vector2, Vector2>();
		var currentDistance = new Dictionary<Vector2, float>();
		var predictedDistance = new Dictionary<Vector2, float>();
		
		// initialize the start node as having a distance of 0, and an estmated distance 
		// of a straight line
		currentDistance.Add(start, 0);
		predictedDistance.Add(start, Vector2.Distance(start, end));

		// if there are any unanalyzed nodes, process them
		while (openSet.Count > 0) {
			var current = openSet.OrderBy((n) => predictedDistance[n]).First();
			
			// if it is the finish, return the path
			if (Vector2.Distance(current, end) < colRect.width) {
				// generate the found path
				cameFrom[end] = current;
				lastPath = ReconstructPath(cameFrom, end);
				return lastPath;
			}
			
			// move current node from open to closed
			openSet.Remove(current);
			closedSet.Add(current);
			
			// process each valid node around the current node
			foreach (var neighbor in Neighbors(current)) {
				if (Vector2.Distance(start, neighbor) > Game.activeSector.sector.radius || (neighbor != start && !IsPassable(neighbor))) {
					continue;
				}
				
				var tempCurrentDistance = currentDistance[current] + 1;
				
				// if we already know a faster way to this neighbor, use that route and 
				// ignore this one
				if (closedSet.Contains(neighbor) && tempCurrentDistance >= currentDistance[neighbor]) {
					continue;
				}
				
				// if we don't know a route to this neighbor, or if this is faster, 
				// store this route
				if (!closedSet.Contains(neighbor) || tempCurrentDistance < currentDistance[neighbor]) {
					cameFrom[neighbor] = current;
					
					currentDistance[neighbor] = tempCurrentDistance;
					predictedDistance[neighbor] =
						currentDistance[neighbor] + Vector2.Distance(neighbor, end);
					
					// if this is a new node, add it to processing
					if (!openSet.Contains(neighbor)) {
						openSet.Add(neighbor);
					}
				}
			}
		}
		
		// unable to figure out a path, abort.
		return null;

	}

	/// <summary>
	/// Process a list of valid paths generated by the Pathfind function and return 
	/// a coherent path to current.
	/// </summary>
	/// <param name="cameFrom">A list of nodes and the origin to that node.</param>
	/// <param name="current">The destination node being sought out.</param>
	/// <returns>The shortest path from the start to the destination node.</returns>
	public static List<Vector2> ReconstructPath(Dictionary<Vector2, Vector2> cameFrom, Vector2 current) {
		if (!cameFrom.Keys.Contains(current)) {
			return new List<Vector2> { current };
		}
		
		var path = ReconstructPath(cameFrom, cameFrom[current]);
		path.Add(current);
		return path;
	}


	public void Update() {
		DebugUtil.DrawRect(pathForm.transform, colRect);
		if (lastPath != null) DebugUtil.DrawPath(lastPath);
	}

	public SpacePather(Blockform form) {
		this.pathForm = form;
		var width = (form.blocks.maxX - form.blocks.minX) * Tile.worldSize;
		var height = (form.blocks.maxY - form.blocks.minY) * Tile.worldSize;
		colRect = new Rect(-width/2, -height/2, width, height);
	}
}
